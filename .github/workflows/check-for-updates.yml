name: Check For New Snapshots
on: 
  schedule:
    - cron: "*/30 6-19 * * *"
  workflow_dispatch:
permissions: 
  actions: write
jobs:
  check:
    env:
      LATEST_VERSION: ${{ vars.LATEST_MC_VERSION }}
      TARGET_VERSION: ${{ vars.TARGET_MC_VERSION }}
    runs-on: ubuntu-latest
    steps:
      - name: Get Version Manifest
        id: version_manifest
        uses: fjogeleit/http-request-action@v1
        with:
          url: "https://piston-meta.mojang.com/mc/game/version_manifest_v2.json"
          method: "GET"
      - name: Check latest snapshot
        uses: actions/github-script@v1
        env:
          NEW_LATEST_VERSION: ${{ fromJson(steps.version_manifest.outputs.response).latest.snapshot }}
        with:
          script: |
            if (process.env.LATEST_VERSION === process.env.TARGET_VERSION) {
              core.info("Latest version is the same as the target version. Not running");
              return;
            }
            
            function getVersionPrefix(name) {
              var type;
              var april = false;
              if (/^\d+\.\d+.\d+$/.test(latestSnapshot)) {
                type = "release";
              } else if (/^\d{2}w\d{2}[a-z]$/.test(latestSnapshot)) {
                type = "snapshot";
              } else if (/^\d+\.\d+.\d+-pre\d+$/.test(latestSnapshot) || /^\d+\.\d+.\d+-rc\d+$/.test(latestSnapshot)) {
                type = "pre";
              } else {
                // If it doesn't match anything guess that it's an april fools release
                type = "snapshot";
                april = true;
              }

              if (type === "snapshot" || type === "pre") {
                if (april) {
                  return "snapshot/april/";
                } else {
                  const targetSplit = process.env.TARGET_VERSION.split(".");
                  return type + "/" + targetSplit[0] + "." + targetSplit[1] + "/";
                }
              } else {
                return type + "/";
              }
            }
            
            function getBranch(release, newVersion) {
              if (release && newVersion) {
                return process.env.TARGET_VERSION + "-release";
              } else if (release && !newVersion) {
                return "upstream/master";
              } else {
                return (newVersion ? "" : "origin/") + process.env.TARGET_VERSION;
              }
            }
            
            const latestSnapshot = process.env.NEW_LATEST_VERSION
            if (process.env.LATEST_VERSION === latestSnapshot) {
              core.info("No new snapshots have been released since " + process.env.LATEST_VERSION)
              return;
            }
            core.info("Found new snapshot: " + latestSnapshot)
            github.request("PATCH /repos/{owner}/{repo}/actions/variables/{name}", {
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: "LATEST_MC_VERSION",
              value: latestSnapshot
            })
            
            var inputs = {}
            inputs.old_version = getVersionPrefix(process.env.LATEST_VERSION) + process.env.LATEST_VERSION;
            inputs.new_version = getVersionPrefix(latestSnapshot) + latestSnapshot;
            
            inputs.old_branch = getBranch(inputs.old_version.startsWith("release/"), false);
            var newBranch = getBranch(inputs.new_version.startsWith("release/"), true);
            if (inputs.old_branch.split("/")[1] !== newBranch) {
              inputs.new_branch = newBranch;
            }
            
            core.info("Using inputs:");
            for (const key in inputs) {
              core.info(key + ": " + inputs[key]);
            }
            
            github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: "update.yml",
              ref: "master",
              inputs: inputs
            });
